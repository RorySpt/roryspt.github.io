<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++ 成员函数指针的一些知识</title>
      <link href="/2023/07/17/modern-cpp/modern-cpp-about-memfn-ptr/"/>
      <url>/2023/07/17/modern-cpp/modern-cpp-about-memfn-ptr/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.cppreference.com/w/cpp/language/member_functions">类的非静态成员函数</a>它们的指针类型为<code>RetType (T::*)(ArgType...)</code>，<code>T</code>为该成员函数所属类的类型，<code>RetType</code>和<code>ArgType</code>分别指代返回值类型和参数类型。</p><p>静态成员函数和普通函数无异，这里不做过多讨论</p><span id="more"></span><h2 id="一些使用问题"><a href="#一些使用问题" class="headerlink" title="一些使用问题"></a>一些使用问题</h2><h3 id="如何识别非静态成员函数指针？"><a href="#如何识别非静态成员函数指针？" class="headerlink" title="如何识别非静态成员函数指针？"></a>如何识别非静态成员函数指针？</h3><p>可以使用<a href="https://zh.cppreference.com/w/cpp/types/is_member_function_pointer"><code>std::is_member_function_pointer&lt;FuncPtrType&gt;</code></a> 检查类型是否为指向非静态成员函数的指针</p><h3 id="如何通过非静态成员函数指针调用非静态成员函数？"><a href="#如何通过非静态成员函数指针调用非静态成员函数？" class="headerlink" title="如何通过非静态成员函数指针调用非静态成员函数？"></a>如何通过非静态成员函数指针调用非静态成员函数？</h3><p>需要配合成员实例使用，可以这样：<code>pObject-&gt;*memFunPtr(ArgType...)</code></p><p>还可以使用<a href="https://zh.cppreference.com/w/cpp/utility/functional/invoke"><code>std::invoke</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/utility/functional/invoke"><code>std::invoke_r</code></a>来调用，但要注意第一个参数要传所属类的实例指针，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_num</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">invoke</span>(&amp;Foo::print_num, foo, <span class="number">1</span>); <span class="comment">// print 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何存储为函数对象"><a href="#如何存储为函数对象" class="headerlink" title="如何存储为函数对象"></a>如何存储为函数对象</h3><p><a href="https://zh.cppreference.com/w/cpp/utility/functional/mem_fn"><code>std::mem_fn</code></a>可以从成员指针创建出函数对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_greeting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你好。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_number</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数字：&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add_xy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data + x + y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">add_many</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data + (args + ...);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">add_them</span><span class="params">(<span class="keyword">auto</span>... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data + (args + ...);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> data = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = Foo&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> greet = std::<span class="built_in">mem_fn</span>(&amp;Foo::display_greeting);</span><br><span class="line">    <span class="built_in">greet</span>(f);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> print_num = std::<span class="built_in">mem_fn</span>(&amp;Foo::display_number);</span><br><span class="line">    <span class="built_in">print_num</span>(f, <span class="number">42</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> access_data = std::<span class="built_in">mem_fn</span>(&amp;Foo::data);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data：&quot;</span> &lt;&lt; <span class="built_in">access_data</span>(f) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> add_xy = std::<span class="built_in">mem_fn</span>(&amp;Foo::add_xy);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_xy：&quot;</span> &lt;&lt; <span class="built_in">add_xy</span>(f, <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用于智能指针</span></span><br><span class="line">    <span class="keyword">auto</span> u = std::<span class="built_in">make_unique</span>&lt;Foo&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;access_data(u)：&quot;</span> &lt;&lt; <span class="built_in">access_data</span>(u) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_xy(u, 1, 2)：&quot;</span> &lt;&lt; <span class="built_in">add_xy</span>(u, <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用于代形参包的成员函数模板</span></span><br><span class="line">    <span class="keyword">auto</span> add_many = std::<span class="built_in">mem_fn</span>(&amp;Foo::add_many&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>&gt;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_many(u, ...)：&quot;</span> &lt;&lt; <span class="built_in">add_many</span>(u, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_them = std::<span class="built_in">mem_fn</span>(&amp;Foo::add_them&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_them(u, ...)：&quot;</span> &lt;&lt; <span class="built_in">add_them</span>(u, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10.0f</span>, <span class="number">13.0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<a href="https://zh.cppreference.com/w/cpp/utility/functional/bind_front"><code>std::bind_front</code></a>来将<code>std::mem_fn</code>返回的函数对象封装成普通函数对象的相似形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = Foo&#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> greet = std::<span class="built_in">mem_fn</span>(&amp;Foo::display_greeting);</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; greet_normal = std::<span class="built_in">bind_front</span>(greet,&amp;f);</span><br><span class="line">    <span class="built_in">greet_normal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="从成员函数指针获取所属类的类型"><a href="#从成员函数指针获取所属类的类型" class="headerlink" title="从成员函数指针获取所属类的类型"></a>从成员函数指针获取所属类的类型</h3><p>msvc编译器内部实现<code>std::_Is_memfunptr</code>可以做到这一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_greeting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你好。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = &amp;Foo::display_greeting;</span><br><span class="line">    <span class="keyword">using</span> Class_type = std::_Is_memfunptr&lt;<span class="keyword">decltype</span>(func)&gt;::_Class_type;</span><br><span class="line">    <span class="keyword">auto</span> f = Class_type&#123;&#125;;</span><br><span class="line">    f.<span class="built_in">display_greeting</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Is_memfunptr</span> &#123; <span class="comment">// base class for member function pointer predicates</span></span><br><span class="line">    <span class="keyword">using</span> _Bool_type = false_type; <span class="comment">// NB: members are user-visible via _Weak_types</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                            \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;class _Ret, class _Arg0, class... _Types&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    struct _Is_memfunptr<span class="string">&lt;_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT&gt;</span> \</span></span><br><span class="line"><span class="meta">        : _Arg_types<span class="string">&lt;CV_OPT _Arg0*, _Types...&gt;</span> &#123;                                          \</span></span><br><span class="line"><span class="meta">        using _Bool_type                                          = true_type;            \</span></span><br><span class="line"><span class="meta">        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret;                 \</span></span><br><span class="line"><span class="meta">        using _Class_type                                         = _Arg0;                \</span></span><br><span class="line"><span class="meta">        using _Guide_type = enable_if<span class="string">&lt;!is_same_v&lt;int REF_OPT, int&amp;&amp;&gt;</span>, _Ret(_Types...)&gt;;   \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br><span class="line"></span><br><span class="line">_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_MEMFUNPTR)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IS_MEMFUNPTR</span></span><br></pre></td></tr></table></figure><p>_Class_type是通过函数的第一个参数来获取的</p><h2 id="更多相关内容"><a href="#更多相关内容" class="headerlink" title="更多相关内容"></a>更多相关内容</h2><ul><li><p><a href="https://zh.cppreference.com/w/cpp/language/operator_member_access">成员访问运算符 - cppreference.com</a></p></li><li><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointer-to-member-operators-dot-star-and-star?view=msvc-170">指向成员的指针运算符：“.*”和“-&gt;*” | Microsoft Learn</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Learn OpenGL] 项目详情</title>
      <link href="/2023/07/04/learn-opengl/project-details/"/>
      <url>/2023/07/04/learn-opengl/project-details/</url>
      
        <content type="html"><![CDATA[<h1 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h1><p>项目sandbox包含以下内容</p><ul><li>display window 封装了窗口相关内容，包含opengl初始化，GLFW初始化，IMGUI初始化，窗口事件等</li><li>render 实现渲染相关内容，具体绘制</li><li>world 代表场景，存放光源（lightsource）、相机（camera）、渲染实体（model）等，它们都以actor实现</li><li>actor 放置在场景里面的所有实体都是actor</li><li>lightsource 对光源的抽象</li><li>camera 对相机的抽象，每个相机对应一个render </li><li>model 可绘制模型</li><li>shader 着色器的抽象，包含顶点着色器和片段着色器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Learn OpenGL] 基础知识</title>
      <link href="/2023/07/04/learn-opengl/basic-knowledge/"/>
      <url>/2023/07/04/learn-opengl/basic-knowledge/</url>
      
        <content type="html"><![CDATA[<h1 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h1><h2 id="缓冲绑定点是什么？"><a href="#缓冲绑定点是什么？" class="headerlink" title="缓冲绑定点是什么？"></a>缓冲绑定点是什么？</h2><p>缓冲绑定点是OpenGL中用于绑定缓冲对象的位置或目标。缓冲对象可以存储各种类型的数据，如顶点数据、索引数据、Uniform数据等。缓冲绑定点提供了一种将指定类型的缓冲对象与特定的目标位置相关联的方式，使得OpenGL可以正确地使用这些缓冲对象中的数据。</p><p>在OpenGL中，常见的缓冲绑定点包括：</p><ol><li>顶点缓冲对象绑定点（Vertex Buffer Object Binding Point）：用于将顶点缓冲对象绑定到顶点属性的位置，以供顶点着色器读取顶点数据。</li><li>索引缓冲对象绑定点（Index Buffer Object Binding Point）：用于将索引缓冲对象绑定到绘制命令中的索引数据位置，以供绘制命令使用。</li><li>Uniform缓冲对象绑定点（Uniform Buffer Object Binding Point）：用于将Uniform缓冲对象绑定到着色器程序中的Uniform变量位置，以供着色器程序读取Uniform数据。</li><li>纹理缓冲对象绑定点（Texture Buffer Object Binding Point）：用于将纹理缓冲对象绑定到纹理单元，以供着色器程序读取纹理数据。</li></ol><p>在使用缓冲对象时，我们需要将缓冲对象绑定到相应的缓冲绑定点上，这样OpenGL才能正确地使用缓冲对象中的数据。而绑定缓冲对象则是通过使用对应的glBindBuffer函数实现的。</p><h2 id="opengl状态机内部数据是如何分布的？"><a href="#opengl状态机内部数据是如何分布的？" class="headerlink" title="opengl状态机内部数据是如何分布的？"></a>opengl状态机内部数据是如何分布的？</h2><p>OpenGL的内部状态由一系列数据和状态变量组成，这些变量存储了OpenGL的各种配置选项、当前绑定的对象和各种状态信息。下面是一些常见的OpenGL状态：</p><ol><li>渲染管线状态（Pipeline State）：包括顶点输入状态、光栅化状态、片段处理状态等。这些状态存储了OpenGL的渲染管线各个阶段的配置选项和设置。</li><li>缓冲绑定状态（Buffer Binding State）：存储了顶点缓冲对象、索引缓冲对象和Uniform缓冲对象等的绑定信息。这些状态记录了当前绑定的缓冲对象的相关属性和数据。</li><li>纹理绑定状态（Texture Binding State）：存储了纹理对象的绑定信息，包括2D纹理、立方体贴图、多重采样纹理等。这些状态记录了当前绑定的纹理对象的相关属性和数据。</li><li>着色器程序状态（Shader Program State）：存储了当前着色器程序的相关信息，包括顶点着色器、片段着色器、几何着色器等。这些状态记录了当前使用的着色器程序的相关属性和数据。</li><li>内存管理状态（Memory Management State）：存储了OpenGL中的内存对象，包括帧缓冲对象、渲染缓冲对象等。这些状态记录了当前内存对象的相关属性和数据。</li><li>视口状态（Viewport State）：存储了OpenGL绘制的视口的相关信息，包括视口的位置和大小。这些状态记录了当前视口的相关属性和数据。</li></ol><p>这些状态和数据被保存在OpenGL当前的上下文中。当我们使用OpenGL API来修改这些状态时，实际上是在修改当前上下文中的对应变量的值。因此，在使用OpenGL时，我们通常会对这些状态进行配置和修改，以达到期望的渲染效果。</p><p>当我们使用OpenGL进行渲染时，需要对一些重要的状态进行配置和修改，以控制渲染的各个方面。下面是一些常见的OpenGL状态的详细说明：</p><ol><li>渲染管线状态（Pipeline State）：包括顶点输入状态、光栅化状态、片段处理状态等。顶点输入状态包括顶点属性缓冲对象的绑定、顶点属性的格式和布局等。光栅化状态包括光栅化模式、剔除模式、多边形模式等。片段处理状态包括混合模式、深度测试、模板测试等。通过配置这些状态，我们可以控制渲染管线各个阶段的行为。</li><li>缓冲绑定状态（Buffer Binding State）：存储了顶点缓冲对象、索引缓冲对象和Uniform缓冲对象的绑定信息。顶点缓冲对象用于存储顶点数据，索引缓冲对象用于存储索引数据，Uniform缓冲对象用于存储着色器程序中的Uniform变量数据。通过绑定不同的缓冲对象，我们可以在渲染时使用不同的数据。</li><li>纹理绑定状态（Texture Binding State）：存储了纹理对象的绑定信息，包括2D纹理、立方体贴图、多重采样纹理等。纹理对象用于存储图像数据，我们可以通过绑定不同的纹理对象来渲染不同的纹理。</li><li>着色器程序状态（Shader Program State）：存储了当前着色器程序的相关信息，包括顶点着色器、片段着色器、几何着色器等。通过配置这些着色器程序，我们可以自定义渲染的算法和效果。</li><li>内存管理状态（Memory Management State）：存储了OpenGL中的内存对象，包括帧缓冲对象、渲染缓冲对象等。通过配置这些内存对象，我们可以定义渲染的目标和方式。</li><li>视口状态（Viewport State）：存储了OpenGL绘制的视口的相关信息，包括视口的位置和大小。通过配置视口，我们可以控制渲染的输出区域和分辨率。</li></ol><p>这些状态的配置和修改通常通过OpenGL API的函数来实现。在使用OpenGL时，我们需要根据具体的需求和场景，对这些状态进行适当的配置和修改，以获得期望的渲染效果。同时，我们还可以通过查询OpenGL的当前状态，了解当前渲染的相关信息，以便进行调试和优化。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>modern c++ usages</title>
      <link href="/2023/07/03/modern-cpp/modern-cpp-usages/"/>
      <url>/2023/07/03/modern-cpp/modern-cpp-usages/</url>
      
        <content type="html"><![CDATA[<h1 id="时间日期（chrono）"><a href="#时间日期（chrono）" class="headerlink" title="时间日期（chrono）"></a>时间日期（chrono）</h1><h2 id="打印当前时间"><a href="#打印当前时间" class="headerlink" title="打印当前时间"></a>打印当前时间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::chrono::zoned_time cur_time&#123; std::chrono::<span class="built_in">current_zone</span>(),</span><br><span class="line">std::chrono::system_clock::<span class="built_in">now</span>() &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;:L%F %H:%M:%OS  %z %Z &#125;\n&quot;</span>, cur_time);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>格式化参考 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock/formatter">std::formatter - cppreference.com</a></p></li><li><p>时间类参考 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">cppreference&#x2F;cpp&#x2F;chrono&#x2F;system_clock</a></p></li><li><p>时区类参考</p><p><a href="https://runebook.dev/zh/docs/cpp/chrono/current_zone">runebook&#x2F;cpp&#x2F;chrono&#x2F;current_zone</a></p><p><a href="https://zh.cppreference.com/w/cpp/chrono/current_zone">cppreference&#x2F;cpp&#x2F;chrono&#x2F;current_zone</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人项目</title>
      <link href="/2023/06/27/myproject/"/>
      <url>/2023/06/27/myproject/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><hr><h2 id="毕业设计功能展示——多功能万年历的设计"><a href="#毕业设计功能展示——多功能万年历的设计" class="headerlink" title="毕业设计功能展示——多功能万年历的设计"></a>毕业设计功能展示——多功能万年历的设计</h2><iframe src="//player.bilibili.com/player.html?aid=455175341&bvid=BV1A5411t7hz&cid=177837592&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="c-太空射手"><a href="#c-太空射手" class="headerlink" title="c++ 太空射手"></a>c++ 太空射手</h2><iframe src="//player.bilibili.com/player.html?aid=374486044&bvid=BV1LZ4y1P7Rk&cid=303106721&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【OpenGL学习】动态光源"><a href="#【OpenGL学习】动态光源" class="headerlink" title="【OpenGL学习】动态光源"></a>【OpenGL学习】动态光源</h2><iframe src="//player.bilibili.com/player.html?aid=431241471&bvid=BV1XG41177LC&cid=850345263&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作品 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Learn OpenGL] 项目配置</title>
      <link href="/2023/06/27/learn-opengl/project-setting/"/>
      <url>/2023/06/27/learn-opengl/project-setting/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://gitee.com/roryspt/opengl-learn/tree/opengl-learn-old">项目地址</a></strong></p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p>找到了glfw模块但是对应的变量没有定义</p><p>使用以下代码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(glfw3 CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(sandbox PRIVATE glfw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(GLFW_FOUND <span class="variable">$&#123;GLFW_FOUND&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW_INCLUDE_DIR <span class="variable">$&#123;GLFW_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW_SOURCES <span class="variable">$&#123;GLFW_SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(GLFW3_FOUND <span class="variable">$&#123;GLFW3_FOUND&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW3_INCLUDE_DIR <span class="variable">$&#123;GLFW3_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW3_SOURCES <span class="variable">$&#123;GLFW3_SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><p>message里的变量都为空，但是<code>target_link_libraries(sandbox PRIVATE glfw)</code>能够成功执行</p><p>glfw库使用以下命令安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install glfw3:x64<span class="literal">-windows</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="CMake使用经验"><a href="#CMake使用经验" class="headerlink" title="CMake使用经验"></a>CMake使用经验</h1><ol><li><p>用文件夹来组织目标 (target)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(GLOBAL PROPERTY USE_FOLDERS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改source_group时，vs需要重新打开才能看到效果</p></li><li><p>多核编译</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(<span class="keyword">target</span> PUBLIC <span class="string">&quot;/MP&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h1 id="git使用经验"><a href="#git使用经验" class="headerlink" title="git使用经验"></a>git使用经验</h1><ol><li><p>重命名（包含修改文件名大小写）,使用以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> <span class="operator">-f</span> test.cpp Test.cpp </span><br></pre></td></tr></table></figure><p>命令文档：<code>git-mv - Move or rename a file, a directory, or a symlink</code></p><p>直接修改文件名会导致git识别不出来的情况</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初次建站</title>
      <link href="/2023/06/24/homepage/"/>
      <url>/2023/06/24/homepage/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="学习中"><a href="#学习中" class="headerlink" title="学习中"></a>学习中</h3><p> <a href="https://zhuanlan.zhihu.com/p/106060640">个人博客第8篇——优化主题（持续更新）</a><br> <a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细）</a><br> <a href="https://hexo.io/zh-cn/docs/configuration">hexo&#x2F;docs&#x2F;configuration</a><br> <a href="https://theme-next.js.org/docs/getting-started/">NexT&#x2F;Getting Started</a><br> <a href="https://hexo-next.readthedocs.io/zh_CN/latest/">hexo-next&#x2F;readthedocs</a><br> <a href="https://blog.csdn.net/witnessai1/article/details/52551362">Markdown语法</a></p><h3 id="网站备注"><a href="#网站备注" class="headerlink" title="网站备注"></a>网站备注</h3><p> <a href="https://fontawesome.com/">Font Awesome</a> —— 图标网站</p><p> <a href="https://smms.app/">SMMS</a> —— 图床网站</p><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><!-- ![background.jpg](https://s2.loli.net/2023/06/24/RODohqMeJjZXxw6.jpg)--><img src="https://s2.loli.net/2023/06/24/RODohqMeJjZXxw6.jpg" style="width:95%; border-radius: 20px;overflow: hidden;" />]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/23/hello-world/"/>
      <url>/2023/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
