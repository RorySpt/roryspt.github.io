<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/08/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>/2023/08/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数中的线性方程组"><a href="#线性代数中的线性方程组" class="headerlink" title="线性代数中的线性方程组"></a>线性代数中的线性方程组</h1><p>线性方程组是线性代数的核心，下面通过简单而具体的设置来引入线性代数的许多重要概念</p><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><p>包含变量$x_1,x_2,\cdots,x_n$的<strong>线性方程</strong>是形如 $a_1x_1+a_2x_2+\dots+a_nx_n&#x3D;b$ 的方程，其中b与系数$a_1,a_2,\dots,a_n$是实数或者复数，通常是已知数。下标n可以是任意正整数。</p><p><strong>线性方程组</strong>是由一个或者几个包含相同变量$x_1,x_2,\cdots,x_n$的线性方程组成的。线性方程组的解是一组数$(s_1,s_2,\dots,s_n)$，用这组数分别代替$x_1,x_2,\cdots,x_n$时所有的方程的两边相等。</p><p>方程组所有可能的解的集合称为线性方程组的解集。若两个线性方程组有相同的解集，则这两个线性方程组称为<strong>等价的</strong>。也就是说，第一个方程组的每个解都是第二个方程组的解，第二个方程组的每个解都是第一个方程组的解</p><blockquote><p>线性方程组的解有下列三种情况：</p><ol><li>无解</li><li>有唯一解</li><li>有无穷多解</li></ol></blockquote><p>我们称一个线性方程组是<strong>相容的</strong>，若他又一个解或者无穷多个解；称他是<strong>不相容的</strong>，若它无解。</p><h3 id="矩阵记号"><a href="#矩阵记号" class="headerlink" title="矩阵记号"></a>矩阵记号</h3><p>一个线性方程组包含的主要信息可以用一个称为<strong>矩阵</strong>的紧凑的矩阵阵列表示<a href="%E5%8F%8D%E8%BF%87%E6%9D%A5%E8%AF%B4%E7%9F%A9%E9%98%B5%E6%98%AF%E8%A1%A8%E7%A4%BA%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%BB%E8%A6%81%E4%BF%A1%E6%81%AF%E7%9A%84%E7%9F%A9%E9%98%B5%E9%98%B5%E5%88%97">^1</a>。给出方程组<br>$$<br>\begin{align}<br>x_1-2x_2+1x_3&amp;&#x3D;0\<br>+2x_2-8x_3&amp;&#x3D;8\<br>5x_1;;;;;;;;;;+5x_3&amp;&#x3D;10<br>\end{align}\tag3<br>$$</p><p>把每一个变量的系数写在对齐的一行中，矩阵<br>$$<br>\begin{bmatrix}<br>1&amp;-2&amp;1\<br>0&amp;2&amp;-8\<br>5&amp;0&amp;-5<br>\end{bmatrix}<br>$$<br>称为方程组 (3) 的<strong>系数矩阵</strong>，而<br>$$<br>\begin{bmatrix}<br>1&amp;-2&amp;1&amp;0\<br>0&amp;2&amp;-8&amp;8\<br>5&amp;0&amp;-5&amp;10<br>\end{bmatrix}\tag4<br>$$<br>称为它的<strong>增广矩阵</strong>。方程组的增广矩阵是把它的系数矩阵添上一列所得，这一列是由方程组右边常数组成的。</p><p>矩阵的<strong>维数</strong>说明它包含行数和列数。上面的增广矩阵（4）有3行4列，称为$3\times4$（读作3行4列）矩阵。若m，n为正整数，$m\times n$矩阵是一个有m行n列的数的矩阵阵列。（行数写在前面。）矩阵记号为解方程组带来便利。</p><h3 id="解线性方程组"><a href="#解线性方程组" class="headerlink" title="解线性方程组"></a>解线性方程组</h3><p>解线性方程组的一般方法的基本思路是把方程组用一个更容易解的等价方程组（即有相同解集的方程组）代替。</p><p>粗略地说，我们用方程组中第一个方程中含$x_1$的项消去其他方程中含x1的项。然后用第二个方程中含$x_2$的项消去其他方程中含$x_2$的项，以此类推。最后我们得到一个很简单的等价方程组。</p><p>用来简化线性方程组的三种基本变换是：把某个方程换成它与另一个方程倍数的和；交换两个方程的位置；把某一个方程的所有项乘以一个非零常数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建型模式</title>
      <link href="/2023/07/30/design-patterns/creational-pattern/"/>
      <url>/2023/07/30/design-patterns/creational-pattern/</url>
      
        <content type="html"><![CDATA[<p>在没有创建型设计模式的时候，在C++中创建对象的行为充满了危险。应该在栈上创建对象，还是应该在堆上创建？应该使用原始指针，使用unique或shared指针，还是应该彻底使用其他对象来管理创建的对象？还有一点，是手动创建对象更合适，还是说应当将包含所有关键信息的创建过程延迟到诸如工厂模式或者控制反转容器等特定的对象构造器中？</p><p>不论选择哪一种方式，创建对象仍旧是一项令人讨厌的工作，尤其是创建过程及其复杂或者需要遵守某些规定的时候。于是，创建型设计模式诞生了：它们是对象创建相关的通用方法。</p><h1 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h1><p>构造器（Builder）模式主要关注复杂对象的创建过程，复杂对象是指的难以通过调用单行构造函数来创建的对象。这些类型的对象本身可能由其他对象组成，并且可能涉及不太明显的逻辑，因此需要专门设计单独的组件来创建。</p><p>构造器模式地目的是简化复杂对象或者一系列对象的构建过程，从而单独定义构成该复杂对象的各个组件的构建方法。</p><ul><li>构造器模式可以通过流式接口调用链来实现复杂的构建过程。为了实现流式接口，构造器的函数需要返回this或*this。为了让构造器使用继承，父类构造器需要知道派生类的实际类型，以便返回实际类型的this，使用模板参数来传递</li><li>为了强调用户使用构造器的API，我们可以将目标对象的构造函数限制为不可访问，同时定义一个create()接口返回构造器。</li><li>通过定义适当的运算符，可以使构造器转换为对象本身。</li><li>借助C++新特性中的统一初始化语法，可以实现Groovy风格的构造器。这是一种很通用的方法，可以创建各式各样的DSL</li><li>单个构造器接口可以暴露出多个子构造器接口。通过灵活的使用继承和流式接口很容易将一个构造器变换为另一个构造器。</li></ul><p>当对象构建过程是非普通的时候，构造器模式是有意义的。对于那些通过数量有限且命名合理的构造函数参数来明确构造的简单对象而言，它们应该使用构造函数（或依赖注入），而不必使用构造器模式。</p><h1 id="工厂方法和抽象工厂"><a href="#工厂方法和抽象工厂" class="headerlink" title="工厂方法和抽象工厂"></a>工厂方法和抽象工厂</h1><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>使用方法来构建预定义型号的对象，替代并隐藏构造函数，强制用户创建特定类型而非任意类型的对象实例</p><h2 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h2><p>专门负责创建特殊类型对象的单独的类，将工厂方法集成到工厂类里，用以追踪已创建对象，实现相互约束</p><h2 id="工厂方法和多态"><a href="#工厂方法和多态" class="headerlink" title="工厂方法和多态"></a>工厂方法和多态</h2><p>不论工厂方法属于被创建的对象本身还是属于单独定义的工厂，使用工厂方法的好处之一是它们可以返回多态类型。</p><h2 id="嵌套工厂"><a href="#嵌套工厂" class="headerlink" title="嵌套工厂"></a>嵌套工厂</h2><p>从构造函数迁移到工厂，涉及以下步骤：</p><ul><li>将构造函数声明为受保护的</li><li>将工厂声明为对象的友元类。如果定义的某些类具有一定的层次结构，那么需要在这个层次结构中的每一个元素重复上面的操作</li><li>在工厂方法内部创建对象，然后以指针形式返回</li></ul><p>上述所有步骤的核心问题在于对象和创建该对象的工厂之间的纠缠。如果工厂在对象之后创建，并且由我们来控制工厂创建的过程，那么包含友元类的声明显然违背了开闭原则。但如果工厂创建一个它自己都无从知晓的对象，将工厂是为友元类显然更不可能</p><p>如果一开始就准备与工厂和对象打交道，那么可以考虑创建嵌套（内部）的工厂，也就是说，在对象内部定义的工厂。</p><p>注：</p><ul><li>嵌套类声明服从<a href="https://zh.cppreference.com/w/cpp/language/access">成员访问</a>说明符，从外围类的作用域之外不能指名私有的成员类，但是可以操作该类的对象。因此可以将嵌套类声明为私有，类实例公开，类实例可以正常访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wall</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">Wall</span>(<span class="type">int</span> id) :<span class="built_in">id</span>(id)&#123;&#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BasicWallFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BasicWallFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Wall&gt; <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Wall&gt;( <span class="keyword">new</span> <span class="built_in">Wall</span>(count++) );<span class="comment">// 无法使用make_shared</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, Wall&amp; wall) &#123;</span><br><span class="line">        <span class="keyword">return</span>  out &lt;&lt; <span class="string">&quot;I&#x27;m a wall, and id is &quot;</span>&lt;&lt; wall.id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> BasicWallFactory factory;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> wall =  Wall::factory.<span class="built_in">create</span>();</span><br><span class="line">    std::cout &lt;&lt; *wall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>参与整个族类对象的创建，实际上是一种非常罕见的场景，因此与工厂方法和旧工厂模式不同，抽象工厂模式是一种只在复杂系统中出现的模式。</p><p>形如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HotDrinkFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;HotDrink&gt; <span class="title">make</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂本身是具有接口的工厂，但它本身是抽象的，可以作为函数的参数，同时也需要具体的实现来生成对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeFactory</span>: <span class="keyword">public</span> HotDrinkFactory&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function">unique_ptr&lt;HotDrink&gt; <span class="title">make</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Coffee&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TeaFactory</span> ...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DrinkFactory</span>&#123;</span><br><span class="line">    map&lt;string, unique_ptr&lt;HotDrinkFactory&gt;&gt; hot_factorys;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DrinkFactory</span>()&#123;</span><br><span class="line">        hot_factorys.<span class="built_in">emplace</span>(<span class="string">&quot;coffee&quot;</span>, <span class="built_in">make_unique</span>&lt;CoffeeFactory&gt;());</span><br><span class="line">        hot_factorys.<span class="built_in">emplace</span>(<span class="string">&quot;tea&quot;</span>, <span class="built_in">make_unique</span>&lt;TeaFactory&gt;());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">unique_ptr&lt;HotDrink&gt; <span class="title">make_drink</span><span class="params">(string_view name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> drink = hot_factorys[name]-&gt;<span class="built_in">make</span>();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> drink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式工厂"><a href="#函数式工厂" class="headerlink" title="函数式工厂"></a>函数式工厂</h2><p>当我们使用术语“工厂”时，通常指的是下面两个概念：</p><ul><li>指一个类，这个类可以创建对象</li><li>指一个函数，当调用这个函数时，可以创建一个对象。</li></ul><p>第二个概念并不是工厂方法的典型使用场景。如果传入<code>function&lt;&gt;</code>类型的参数（或者普通函数指针），该函数返回类型为T的变量，这也是一种工厂而不是工厂方法。</p><p>幸运的是，函数可以保存在变量中，这可以通过将工厂替换为函数块来实现。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DrinkFactory</span>&#123;</span><br><span class="line">    map&lt;string, std::function&lt;unique_ptr&lt;HotDrink&gt;()&gt;&gt; hot_factorys;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DrinkFactory</span>()&#123;</span><br><span class="line">        hot_factorys.<span class="built_in">emplace</span>(<span class="string">&quot;coffee&quot;</span>, []()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Coffee&gt;();</span><br><span class="line">        &#125;);</span><br><span class="line">        hot_factorys.<span class="built_in">emplace</span>(<span class="string">&quot;tea&quot;</span>, []()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Tea&gt;();</span><br><span class="line">        &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">unique_ptr&lt;HotDrink&gt; <span class="title">make_drink</span><span class="params">(string_view name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> drink = hot_factorys[name]();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> drink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--*它们和抽象工厂表达的行为是一致的，由类表现多态改为函数来实现多态* --><h2 id="对象追踪"><a href="#对象追踪" class="headerlink" title="对象追踪"></a>对象追踪</h2><p>与调用构造函数相比，工厂更难使用（不像构造函数那么明确），如果能从工厂中获取某些便利就好了。使用工厂的一种便利是，可以追踪所有已经创建的对象。</p><p>使用工厂的好处包括：</p><ul><li>可以知道已经创建的特定类型的对象数量。</li><li>可以修改或者完全替换整个对象（在数学意义上）的创建过程</li><li>如果使用智能指针，则可以通过观察对象的引用计数来获取对象在其他地方被引用的数量</li></ul><p>服务定位器或者反转容器可以采取这种对象追踪策略。这样容器可以以<code>shared_ptr</code>的形式构建对象，但在内部以<code>weak_ptr</code>的形式管理，这样既可以观察对象状态，又可以在运行时完全替换为新的对象</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>工厂方法：类的成员函数，用于创建对象。它通常可以替换构造函数</li><li>工厂：一个类，它知道如何创建对象。不过，如果我们给一个函数传入可创建的对象的参数（如函数或者类似的“对象”），那么这个参数也被称为工厂</li><li>抽象工厂：正如其名称所表示的意义，抽象类可以被具体类的类继承，由此产生了一个工厂类族。实际开发中抽象工厂很少见。</li></ul><p>相比调用构造函数，使用工厂有几个关键优势，即：</p><ul><li>工厂方法可以拒绝构建对象，也就是说，工厂可以返回默认初始化的智能指针，可以返回<code>optional&lt;T&gt;</code>或者空指针<code>nullptr</code>，而不是必须返回一个对象。</li><li>工厂方法可以是多态的，因此工厂方法可以返回基类或者基类的指针。使用其他方式（比如使用variant），工厂方法还可以支持返回不同的数据类型</li><li>与构造函数命名不同，工厂方法的命名不受约束并且可以更有意义，我们可以将其命名为任何名称。</li><li>工厂可以实现缓存和其他存储优化；对于诸如池或者单例模式之类的方法来说，这也是一种不错的选择</li><li>工厂可以将对象不同的关注点内容（比如验证代码）封装（即关注点分离）</li></ul><p>工厂模式与构造器模式的差别在于，使用工厂模式，我们可以一次创建一个完整的对象；而使用构造器模式，则需要分步提供对象的部分信息才能逐步完成一个对象的构建。</p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn Design Patterns </category>
          
          <category> Learn Creational Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Creational Pattern </tag>
            
            <tag> Design Patterns </tag>
            
            <tag> Learn </tag>
            
            <tag> Reading Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID 设计原则</title>
      <link href="/2023/07/29/design-patterns/solid/"/>
      <url>/2023/07/29/design-patterns/solid/</url>
      
        <content type="html"><![CDATA[<p>SOLID 是一个缩写，代表以下设计原则：</p><ul><li>单一职责原则（Single Responsibility Principle，SRP）</li><li>开闭原则（Open-Closed Principle，OCP）</li><li>里氏替换原则（Liskov Substitution Principle，LSP）</li><li>接口隔离原则（Interface Segregation Principle，ISP）</li><li>依赖倒转原则（Dependency Inversion Principle，DIP）</li></ul><p>这些原则是Robert C. Martin 在21世纪初提出的——实际上，这只是从Robert的著作和博客中阐述的几十条原则中选出来的5条</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>每个类只有一个职责，因此也只有一个修改该类的原因（即只有该职责变化时，该类才做相应的修改）</p><p>违背单一职责原则的一个极端的反面模式被称为上帝对象（God Object）。上帝对象指的是承担了尽可能多的职责的庞大的类，是一个极其难以对付的庞大的“怪物”！</p><p>反面模式也是一种模式，不幸的是，他经常出现在代码中，以至于被广泛的认识。模式和反面模式的区别在于，反面模式通常是糟糕的设计的典型案例，它会导致代码难以理解，难以维护和难以重构。</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>开闭原则要求软件对拓展开放，对修改关闭。开闭原则的主旨是，我们不必返回到已编写和测试的代码来修改它。</p><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>以 Barbara Liskov 命名的里氏替换原则指出，如果某个接口以基类Parent类型的对象为参数，那么他应该同等地接受子类Child类对象作为参数，并且程序不会产生任何异常</p><p>如果子类重写了父类方法，处理父类的函数如果依赖父类中的该方法，其用于处理子类时就可能会出现异常</p><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>接口隔离原则的基本思想是将复杂的接口分离为多个单独的接口，以避免强制实现者必须实现某些它们并不需要的接口。任何时候，当我们要为某个复杂的应用程序编写插件时，如果要基于某个包含20个复杂功能的接口并且大部分接口实际上没有任何操作仅仅返回nullptr进行开发，那么这个API设计者很可能违背了接口隔离原则。</p><h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><p>依赖倒转原则的原始定义如下几点：</p><ul><li>高层模块不应该依赖低层模块，它们都应该依赖抽象接口。</li><li>抽象接口不应该依赖细节，细节应该依赖抽象接口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn Design Patterns </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Patterns </tag>
            
            <tag> Learn </tag>
            
            <tag> Reading Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 成员函数指针的一些知识</title>
      <link href="/2023/07/17/modern-cpp/modern-cpp-about-memfn-ptr/"/>
      <url>/2023/07/17/modern-cpp/modern-cpp-about-memfn-ptr/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.cppreference.com/w/cpp/language/member_functions">类的非静态成员函数</a>它们的指针类型为<code>RetType (T::*)(ArgType...)</code>，<code>T</code>为该成员函数所属类的类型，<code>RetType</code>和<code>ArgType</code>分别指代返回值类型和参数类型。</p><p>静态成员函数和普通函数无异，这里不做过多讨论</p><span id="more"></span><h2 id="一些使用问题"><a href="#一些使用问题" class="headerlink" title="一些使用问题"></a>一些使用问题</h2><h3 id="如何识别非静态成员函数指针？"><a href="#如何识别非静态成员函数指针？" class="headerlink" title="如何识别非静态成员函数指针？"></a>如何识别非静态成员函数指针？</h3><p>可以使用<a href="https://zh.cppreference.com/w/cpp/types/is_member_function_pointer"><code>std::is_member_function_pointer&lt;FuncPtrType&gt;</code></a> 检查类型是否为指向非静态成员函数的指针</p><h3 id="如何通过非静态成员函数指针调用非静态成员函数？"><a href="#如何通过非静态成员函数指针调用非静态成员函数？" class="headerlink" title="如何通过非静态成员函数指针调用非静态成员函数？"></a>如何通过非静态成员函数指针调用非静态成员函数？</h3><p>需要配合成员实例使用，可以这样：<code>pObject-&gt;*memFunPtr(ArgType...)</code></p><p>还可以使用<a href="https://zh.cppreference.com/w/cpp/utility/functional/invoke"><code>std::invoke</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/utility/functional/invoke"><code>std::invoke_r</code></a>来调用，但要注意第一个参数要传所属类的实例指针，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_num</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">invoke</span>(&amp;Foo::print_num, foo, <span class="number">1</span>); <span class="comment">// print 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何存储为函数对象"><a href="#如何存储为函数对象" class="headerlink" title="如何存储为函数对象"></a>如何存储为函数对象</h3><p><a href="https://zh.cppreference.com/w/cpp/utility/functional/mem_fn"><code>std::mem_fn</code></a>可以从成员指针创建出函数对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_greeting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你好。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_number</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数字：&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add_xy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data + x + y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">add_many</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data + (args + ...);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">add_them</span><span class="params">(<span class="keyword">auto</span>... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data + (args + ...);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> data = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = Foo&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> greet = std::<span class="built_in">mem_fn</span>(&amp;Foo::display_greeting);</span><br><span class="line">    <span class="built_in">greet</span>(f);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> print_num = std::<span class="built_in">mem_fn</span>(&amp;Foo::display_number);</span><br><span class="line">    <span class="built_in">print_num</span>(f, <span class="number">42</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> access_data = std::<span class="built_in">mem_fn</span>(&amp;Foo::data);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;data：&quot;</span> &lt;&lt; <span class="built_in">access_data</span>(f) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> add_xy = std::<span class="built_in">mem_fn</span>(&amp;Foo::add_xy);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_xy：&quot;</span> &lt;&lt; <span class="built_in">add_xy</span>(f, <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用于智能指针</span></span><br><span class="line">    <span class="keyword">auto</span> u = std::<span class="built_in">make_unique</span>&lt;Foo&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;access_data(u)：&quot;</span> &lt;&lt; <span class="built_in">access_data</span>(u) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_xy(u, 1, 2)：&quot;</span> &lt;&lt; <span class="built_in">add_xy</span>(u, <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用于代形参包的成员函数模板</span></span><br><span class="line">    <span class="keyword">auto</span> add_many = std::<span class="built_in">mem_fn</span>(&amp;Foo::add_many&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>&gt;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_many(u, ...)：&quot;</span> &lt;&lt; <span class="built_in">add_many</span>(u, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_them = std::<span class="built_in">mem_fn</span>(&amp;Foo::add_them&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add_them(u, ...)：&quot;</span> &lt;&lt; <span class="built_in">add_them</span>(u, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10.0f</span>, <span class="number">13.0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<a href="https://zh.cppreference.com/w/cpp/utility/functional/bind_front"><code>std::bind_front</code></a>来将<code>std::mem_fn</code>返回的函数对象封装成普通函数对象的相似形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = Foo&#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> greet = std::<span class="built_in">mem_fn</span>(&amp;Foo::display_greeting);</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; greet_normal = std::<span class="built_in">bind_front</span>(greet,&amp;f);</span><br><span class="line">    <span class="built_in">greet_normal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="从成员函数指针获取所属类的类型"><a href="#从成员函数指针获取所属类的类型" class="headerlink" title="从成员函数指针获取所属类的类型"></a>从成员函数指针获取所属类的类型</h3><p>msvc编译器内部实现<code>std::_Is_memfunptr</code>可以做到这一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_greeting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你好。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = &amp;Foo::display_greeting;</span><br><span class="line">    <span class="keyword">using</span> Class_type = std::_Is_memfunptr&lt;<span class="keyword">decltype</span>(func)&gt;::_Class_type;</span><br><span class="line">    <span class="keyword">auto</span> f = Class_type&#123;&#125;;</span><br><span class="line">    f.<span class="built_in">display_greeting</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Is_memfunptr</span> &#123; <span class="comment">// base class for member function pointer predicates</span></span><br><span class="line">    <span class="keyword">using</span> _Bool_type = false_type; <span class="comment">// NB: members are user-visible via _Weak_types</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                            \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;class _Ret, class _Arg0, class... _Types&gt;</span>                                   \</span></span><br><span class="line"><span class="meta">    struct _Is_memfunptr<span class="string">&lt;_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT&gt;</span> \</span></span><br><span class="line"><span class="meta">        : _Arg_types<span class="string">&lt;CV_OPT _Arg0*, _Types...&gt;</span> &#123;                                          \</span></span><br><span class="line"><span class="meta">        using _Bool_type                                          = true_type;            \</span></span><br><span class="line"><span class="meta">        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret;                 \</span></span><br><span class="line"><span class="meta">        using _Class_type                                         = _Arg0;                \</span></span><br><span class="line"><span class="meta">        using _Guide_type = enable_if<span class="string">&lt;!is_same_v&lt;int REF_OPT, int&amp;&amp;&gt;</span>, _Ret(_Types...)&gt;;   \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br><span class="line"></span><br><span class="line">_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_MEMFUNPTR)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IS_MEMFUNPTR</span></span><br></pre></td></tr></table></figure><p>_Class_type是通过函数的第一个参数来获取的</p><h2 id="更多相关内容"><a href="#更多相关内容" class="headerlink" title="更多相关内容"></a>更多相关内容</h2><ul><li><p><a href="https://zh.cppreference.com/w/cpp/language/operator_member_access">成员访问运算符 - cppreference.com</a></p></li><li><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointer-to-member-operators-dot-star-and-star?view=msvc-170">指向成员的指针运算符：“.*”和“-&gt;*” | Microsoft Learn</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Learn OpenGL] 项目详情</title>
      <link href="/2023/07/04/learn-opengl/project-details/"/>
      <url>/2023/07/04/learn-opengl/project-details/</url>
      
        <content type="html"><![CDATA[<h1 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h1><p>项目sandbox包含以下内容</p><ul><li>display window 封装了窗口相关内容，包含opengl初始化，GLFW初始化，IMGUI初始化，窗口事件等</li><li>render 实现渲染相关内容，具体绘制</li><li>world 代表场景，存放光源（lightsource）、相机（camera）、渲染实体（model）等，它们都以actor实现</li><li>actor 放置在场景里面的所有实体都是actor</li><li>lightsource 对光源的抽象</li><li>camera 对相机的抽象，每个相机对应一个render </li><li>model 可绘制模型</li><li>shader 着色器的抽象，包含顶点着色器和片段着色器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Learn OpenGL] 基础知识</title>
      <link href="/2023/07/04/learn-opengl/basic-knowledge/"/>
      <url>/2023/07/04/learn-opengl/basic-knowledge/</url>
      
        <content type="html"><![CDATA[<h1 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h1><h2 id="缓冲绑定点是什么？"><a href="#缓冲绑定点是什么？" class="headerlink" title="缓冲绑定点是什么？"></a>缓冲绑定点是什么？</h2><p>缓冲绑定点是OpenGL中用于绑定缓冲对象的位置或目标。缓冲对象可以存储各种类型的数据，如顶点数据、索引数据、Uniform数据等。缓冲绑定点提供了一种将指定类型的缓冲对象与特定的目标位置相关联的方式，使得OpenGL可以正确地使用这些缓冲对象中的数据。</p><p>在OpenGL中，常见的缓冲绑定点包括：</p><ol><li>顶点缓冲对象绑定点（Vertex Buffer Object Binding Point）：用于将顶点缓冲对象绑定到顶点属性的位置，以供顶点着色器读取顶点数据。</li><li>索引缓冲对象绑定点（Index Buffer Object Binding Point）：用于将索引缓冲对象绑定到绘制命令中的索引数据位置，以供绘制命令使用。</li><li>Uniform缓冲对象绑定点（Uniform Buffer Object Binding Point）：用于将Uniform缓冲对象绑定到着色器程序中的Uniform变量位置，以供着色器程序读取Uniform数据。</li><li>纹理缓冲对象绑定点（Texture Buffer Object Binding Point）：用于将纹理缓冲对象绑定到纹理单元，以供着色器程序读取纹理数据。</li></ol><p>在使用缓冲对象时，我们需要将缓冲对象绑定到相应的缓冲绑定点上，这样OpenGL才能正确地使用缓冲对象中的数据。而绑定缓冲对象则是通过使用对应的glBindBuffer函数实现的。</p><h2 id="opengl状态机内部数据是如何分布的？"><a href="#opengl状态机内部数据是如何分布的？" class="headerlink" title="opengl状态机内部数据是如何分布的？"></a>opengl状态机内部数据是如何分布的？</h2><p>OpenGL的内部状态由一系列数据和状态变量组成，这些变量存储了OpenGL的各种配置选项、当前绑定的对象和各种状态信息。下面是一些常见的OpenGL状态：</p><ol><li>渲染管线状态（Pipeline State）：包括顶点输入状态、光栅化状态、片段处理状态等。这些状态存储了OpenGL的渲染管线各个阶段的配置选项和设置。</li><li>缓冲绑定状态（Buffer Binding State）：存储了顶点缓冲对象、索引缓冲对象和Uniform缓冲对象等的绑定信息。这些状态记录了当前绑定的缓冲对象的相关属性和数据。</li><li>纹理绑定状态（Texture Binding State）：存储了纹理对象的绑定信息，包括2D纹理、立方体贴图、多重采样纹理等。这些状态记录了当前绑定的纹理对象的相关属性和数据。</li><li>着色器程序状态（Shader Program State）：存储了当前着色器程序的相关信息，包括顶点着色器、片段着色器、几何着色器等。这些状态记录了当前使用的着色器程序的相关属性和数据。</li><li>内存管理状态（Memory Management State）：存储了OpenGL中的内存对象，包括帧缓冲对象、渲染缓冲对象等。这些状态记录了当前内存对象的相关属性和数据。</li><li>视口状态（Viewport State）：存储了OpenGL绘制的视口的相关信息，包括视口的位置和大小。这些状态记录了当前视口的相关属性和数据。</li></ol><p>这些状态和数据被保存在OpenGL当前的上下文中。当我们使用OpenGL API来修改这些状态时，实际上是在修改当前上下文中的对应变量的值。因此，在使用OpenGL时，我们通常会对这些状态进行配置和修改，以达到期望的渲染效果。</p><p>当我们使用OpenGL进行渲染时，需要对一些重要的状态进行配置和修改，以控制渲染的各个方面。下面是一些常见的OpenGL状态的详细说明：</p><ol><li>渲染管线状态（Pipeline State）：包括顶点输入状态、光栅化状态、片段处理状态等。顶点输入状态包括顶点属性缓冲对象的绑定、顶点属性的格式和布局等。光栅化状态包括光栅化模式、剔除模式、多边形模式等。片段处理状态包括混合模式、深度测试、模板测试等。通过配置这些状态，我们可以控制渲染管线各个阶段的行为。</li><li>缓冲绑定状态（Buffer Binding State）：存储了顶点缓冲对象、索引缓冲对象和Uniform缓冲对象的绑定信息。顶点缓冲对象用于存储顶点数据，索引缓冲对象用于存储索引数据，Uniform缓冲对象用于存储着色器程序中的Uniform变量数据。通过绑定不同的缓冲对象，我们可以在渲染时使用不同的数据。</li><li>纹理绑定状态（Texture Binding State）：存储了纹理对象的绑定信息，包括2D纹理、立方体贴图、多重采样纹理等。纹理对象用于存储图像数据，我们可以通过绑定不同的纹理对象来渲染不同的纹理。</li><li>着色器程序状态（Shader Program State）：存储了当前着色器程序的相关信息，包括顶点着色器、片段着色器、几何着色器等。通过配置这些着色器程序，我们可以自定义渲染的算法和效果。</li><li>内存管理状态（Memory Management State）：存储了OpenGL中的内存对象，包括帧缓冲对象、渲染缓冲对象等。通过配置这些内存对象，我们可以定义渲染的目标和方式。</li><li>视口状态（Viewport State）：存储了OpenGL绘制的视口的相关信息，包括视口的位置和大小。通过配置视口，我们可以控制渲染的输出区域和分辨率。</li></ol><p>这些状态的配置和修改通常通过OpenGL API的函数来实现。在使用OpenGL时，我们需要根据具体的需求和场景，对这些状态进行适当的配置和修改，以获得期望的渲染效果。同时，我们还可以通过查询OpenGL的当前状态，了解当前渲染的相关信息，以便进行调试和优化。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>modern c++ usages</title>
      <link href="/2023/07/03/modern-cpp/modern-cpp-usages/"/>
      <url>/2023/07/03/modern-cpp/modern-cpp-usages/</url>
      
        <content type="html"><![CDATA[<h1 id="时间日期（chrono）"><a href="#时间日期（chrono）" class="headerlink" title="时间日期（chrono）"></a>时间日期（chrono）</h1><h2 id="打印当前时间"><a href="#打印当前时间" class="headerlink" title="打印当前时间"></a>打印当前时间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::chrono::zoned_time cur_time&#123; std::chrono::<span class="built_in">current_zone</span>(),</span><br><span class="line">std::chrono::system_clock::<span class="built_in">now</span>() &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;:L%F %H:%M:%OS  %z %Z &#125;\n&quot;</span>, cur_time);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>格式化参考 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock/formatter">std::formatter - cppreference.com</a></p></li><li><p>时间类参考 <a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">cppreference&#x2F;cpp&#x2F;chrono&#x2F;system_clock</a></p></li><li><p>时区类参考</p><p><a href="https://runebook.dev/zh/docs/cpp/chrono/current_zone">runebook&#x2F;cpp&#x2F;chrono&#x2F;current_zone</a></p><p><a href="https://zh.cppreference.com/w/cpp/chrono/current_zone">cppreference&#x2F;cpp&#x2F;chrono&#x2F;current_zone</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人项目</title>
      <link href="/2023/06/27/myproject/"/>
      <url>/2023/06/27/myproject/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><hr><h2 id="毕业设计功能展示——多功能万年历的设计"><a href="#毕业设计功能展示——多功能万年历的设计" class="headerlink" title="毕业设计功能展示——多功能万年历的设计"></a>毕业设计功能展示——多功能万年历的设计</h2><iframe src="//player.bilibili.com/player.html?aid=455175341&bvid=BV1A5411t7hz&cid=177837592&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="c-太空射手"><a href="#c-太空射手" class="headerlink" title="c++ 太空射手"></a>c++ 太空射手</h2><iframe src="//player.bilibili.com/player.html?aid=374486044&bvid=BV1LZ4y1P7Rk&cid=303106721&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="【OpenGL学习】动态光源"><a href="#【OpenGL学习】动态光源" class="headerlink" title="【OpenGL学习】动态光源"></a>【OpenGL学习】动态光源</h2><iframe src="//player.bilibili.com/player.html?aid=431241471&bvid=BV1XG41177LC&cid=850345263&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作品 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Learn OpenGL] 项目配置</title>
      <link href="/2023/06/27/learn-opengl/project-setting/"/>
      <url>/2023/06/27/learn-opengl/project-setting/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://gitee.com/roryspt/opengl-learn/tree/opengl-learn-old">项目地址</a></strong></p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p>找到了glfw模块但是对应的变量没有定义</p><p>使用以下代码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(glfw3 CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(sandbox PRIVATE glfw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(GLFW_FOUND <span class="variable">$&#123;GLFW_FOUND&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW_INCLUDE_DIR <span class="variable">$&#123;GLFW_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW_SOURCES <span class="variable">$&#123;GLFW_SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(GLFW3_FOUND <span class="variable">$&#123;GLFW3_FOUND&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW3_INCLUDE_DIR <span class="variable">$&#123;GLFW3_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(GLFW3_SOURCES <span class="variable">$&#123;GLFW3_SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><p>message里的变量都为空，但是<code>target_link_libraries(sandbox PRIVATE glfw)</code>能够成功执行</p><p>glfw库使用以下命令安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install glfw3:x64<span class="literal">-windows</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="CMake使用经验"><a href="#CMake使用经验" class="headerlink" title="CMake使用经验"></a>CMake使用经验</h1><ol><li><p>用文件夹来组织目标 (target)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(GLOBAL PROPERTY USE_FOLDERS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改source_group时，vs需要重新打开才能看到效果</p></li><li><p>多核编译</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(<span class="keyword">target</span> PUBLIC <span class="string">&quot;/MP&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h1 id="git使用经验"><a href="#git使用经验" class="headerlink" title="git使用经验"></a>git使用经验</h1><ol><li><p>重命名（包含修改文件名大小写）,使用以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> <span class="operator">-f</span> test.cpp Test.cpp </span><br></pre></td></tr></table></figure><p>命令文档：<code>git-mv - Move or rename a file, a directory, or a symlink</code></p><p>直接修改文件名会导致git识别不出来的情况</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
          <category> Learn OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learn </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初次建站</title>
      <link href="/2023/06/24/homepage/"/>
      <url>/2023/06/24/homepage/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="学习中"><a href="#学习中" class="headerlink" title="学习中"></a>学习中</h3><p> <a href="https://zhuanlan.zhihu.com/p/106060640">个人博客第8篇——优化主题（持续更新）</a><br> <a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细）</a><br> <a href="https://hexo.io/zh-cn/docs/configuration">hexo&#x2F;docs&#x2F;configuration</a><br> <a href="https://theme-next.js.org/docs/getting-started/">NexT&#x2F;Getting Started</a><br> <a href="https://hexo-next.readthedocs.io/zh_CN/latest/">hexo-next&#x2F;readthedocs</a><br> <a href="https://blog.csdn.net/witnessai1/article/details/52551362">Markdown语法</a></p><h3 id="网站备注"><a href="#网站备注" class="headerlink" title="网站备注"></a>网站备注</h3><p> <a href="https://fontawesome.com/">Font Awesome</a> —— 图标网站</p><p> <a href="https://smms.app/">SMMS</a> —— 图床网站</p><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><!-- ![background.jpg](https://s2.loli.net/2023/06/24/RODohqMeJjZXxw6.jpg)--><img src="https://s2.loli.net/2023/06/24/RODohqMeJjZXxw6.jpg" style="width:95%; border-radius: 20px;overflow: hidden;" />]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/23/hello-world/"/>
      <url>/2023/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
